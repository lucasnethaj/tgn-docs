name: Nightly build
on:
  workflow_dispatch:
  schedule:
    - cron: '0 21 * * *'

env:
  ## Sets environment variable
  RETENTION_DAYS_BINS: 3
  ## TODO: add ldc2/dmd switch & version
jobs:
  run_bdd_tests:
    runs-on: self-hosted
    steps:
      
      - name: Cleanup
        run: |
          sudo rm -rf *
          sudo rm -rf .git
          sudo rm -rf .github
          sudo rm -rf .vscode
      - name: Download bins
        uses: dawidd6/action-download-artifact@v2
        with:
          name: bins-logs
          workflow: daily.yml
          path: bins-logs
      - name: Run Bdd tests
        run: |
          source ~/.bashrc
          ls
          ls bins-logs
          
          sudo chmod +x ./bins-logs/*
          sudo chmod 777 ./bins-logs/**
          ./bins-logs/tagion -f
          mkdir logs
          mkdir -p $PWD/logs/bdd/commit/results/
          mkdir -p $PWD/logs/bdd/acceptance/results/
          mkdir -p $PWD/logs/bdd/performance/results/
          export DBIN=$PWD/bins-logs
          export DLOG=$PWD/logs
          export BDD=$PWD/bins-logs/bdd
          export TESTLOG=$PWD/logs/testlog
          export FUND=$PWD/bins-logs/fundamental
          export REPOROOT=$PWD
          export TEST_STAGE=commit
          PATH=$DBIN:$PATH
          setup_env () {
            export TEST_STAGE=$1
            export BDD_LOG=$PWD/logs/bdd/$1/
            export BDD_RESULTS=$PWD/logs/bdd/$1/results/
          }
          
          setup_env commit
          while read -r line
          do
            scenario=$(echo $line  | head -n1 | cut -d " " -f1)
            setup_env commit
            echo "run commit env $scenario"
            testbench $scenario

            setup_env acceptance
            echo "run acceptance env $scenario"
            testbench $scenario

            setup_env performance
            echo "run performance env $scenario"
            testbench $scenario
          done <<< $(testbench -f)
          report () {
            collider -cv ./logs/bdd/$1/results/ > ./logs/bdd/$1/results/output.log
            echo "## ${1^} STAGE" >> $GITHUB_STEP_SUMMARY
            cat ./logs/bdd/$1/results/output.log | sed 's/\x1B\[[0-9;]*[a-zA-Z]//g' >> $GITHUB_STEP_SUMMARY
          }
          report commit
          report acceptance
          report performance
     

      - name: Upload Bdd result
        uses: actions/upload-artifact@v3
        with:
          name: core-bdd-logs
          path: ./logs/bdd/
          retention-days: ${{ env.RETENTION_DAYS_BINS }}
      
      - name: Socket test
        run: |
          export TB_TESTROOT=build/${{ env.TARGET_BUILD }}/test
          export TB_TESTDIR=$(date "+socktest.%y%m%d%H%M")
          export TB_LOGDIR=logs/${{ env.TARGET_BUILD }}/socktest
          export TB_ARTIFACT=build/${{ env.TARGET_BUILD }}/bin/tagion
          mkdir -p $TB_LOGDIR
          chmod 755 bdd/extras/sockets/socktest.sh
          bdd/extras/sockets/socktest.sh > logs/${{ env.TARGET_BUILD }}/socktest/$TB_TESTDIR.test.log 2>/dev/null 
      - name: Upload socket test results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: core-socktest-logs
          path: logs/${{ env.TARGET_BUILD }}/socktest

      - name: Report socket test results
        if: always()
        run: |
          tail -n 5 logs/${{ env.TARGET_BUILD }}/socktest/$TB_TESTDIR.test.log >> $GITHUB_STEP_SUMMARY

      # - name: Report Bdd result
      #   run: |
      #     cat ./bddconsole.log | tail -n 3 >> $GITHUB_STEP_SUMMARY
      # # - name: Check bdd result
      # #  run: cat ./bddconsole.log | tail -n 1 | grep -E "Test result success!"
      # - name: Set current date as env variable
      #   run: echo "NOW=$(date +%s)" >> $GITHUB_ENV
      # - id: commit
      #   uses: pr-mpt/actions-commit-hash@v2
      # - run: |
      #     tar -czvf ${{ env.NOW }}_tagion_${{ steps.commit.outputs.short }}.tar.gz ./build/${{ env.TARGET_BUILD }}/bin/tagion
      #     export AWS_ACCESS_KEY_ID=${{ secrets.AWS_KEY_ID }}
      #     export AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY}}
      #     aws s3 cp ${{ env.NOW }}_tagion_${{ steps.commit.outputs.short }}.tar.gz s3://core-tagion
      #     aws s3 ls core-tagion
      
  # create_tagion_images:
  #   runs-on: self-hosted
  #   needs: build_and_unittest
  #   outputs:
  #     scenario_list: ${{ steps.scenario_list.outputs.scenarious }}
  #     scenario_matrix: ${{ steps.scenario_list.outputs.scenariousmatrix }}
  #   steps:
  #     - name: Cleanup
  #       run: rm -rf * ; ls; pwd;

  #     - name: Download Docker context
  #       uses: actions/checkout@v3
  #       with:
  #         repository: tagion/tagion-docker
  #         token: ${{ secrets.GH_PAT }} # `GH_PAT` is a secret that contains your PAT

  #     - name: Download bins
  #       uses: actions/download-artifact@v3
  #       with:
  #         name: core-bins
  #         path: bins
 
  #     - name: Download QA tools
  #       uses: actions/checkout@v3
  #       with:
  #         repository: tagion/qa-framework
  #         token: ${{ secrets.GH_PAT }} # `GH_PAT` is a secret that contains your PAT
  #         path: qa-tools

  #     - name: Debug info
  #       run: ls; echo ===========; ls bins; echo ===========; ls qa-tools; pwd;

  #     - name: Login to Docker Hub
  #       uses: docker/login-action@v2
  #       with:
  #         username: ${{ secrets.DOCKERHUB_USERNAME }}
  #         password: ${{ secrets.DOCKERHUB_TOKEN }}
      
  #     - name: Build tagion img
  #       run: docker build -t tagion/toolkit:$GITHUB_SHA . --target tagion
  #     - name: Build tagion-qa img
  #       run: docker build -t tagion/qa-toolkit:$GITHUB_SHA . --target tagion-qa

  #     - name: Push tagion img
  #       run: docker image push tagion/toolkit:$GITHUB_SHA
  #     - name: Push tagion-qa img
  #       run: docker image push tagion/qa-toolkit:$GITHUB_SHA

  #     - name: List scenarious
  #       id: scenario_list
  #       run: |
  #         SCENARIOUS=""
  #         while read f; do
  #             SCENARIOUS+="${f} "
  #         done < "./qa-tools/scenarios.txt"
  #         echo $SCENARIOUS
  #         echo "scenarious=$SCENARIOUS" >> $GITHUB_OUTPUT
  #         SCENARIOUS_MATRIX=$(echo $(cat ./qa-tools/scenarios.txt | jq -R -s -c 'split("\n")[:-1]') | sed 's/ //g')
  #         echo $SCENARIOUS_MATRIX
  #         echo "scenariousmatrix=$SCENARIOUS_MATRIX" >> $GITHUB_OUTPUT
  #     - name: Report created docker
  #       if: success()
  #       run: |
  #         echo -e "### :heavy_check_mark: Docker created \n [tagion/toolkit:$GITHUB_SHA](https://hub.docker.com/repository/docker/tagion/toolkit) \n [tagion/qa-toolkit:$GITHUB_SHA](https://hub.docker.com/repository/docker/tagion/qa-toolkit)" >> $GITHUB_STEP_SUMMARY
    
      
  # before_run:
  #   runs-on: self-hosted
  #   needs: create_tagion_images
  #   steps: 
    
  #     - id: commit
  #       uses: pr-mpt/actions-commit-hash@v2
  #     - name: Cleanup
  #       run: rm -rf * ; ls; pwd;

  #     - name: Debug info - input
  #       run: echo ${{needs.create_tagion_images.outputs.scenario_list}} 
        
  #     - name: Debug info - input matrix
  #       run: echo ${{needs.create_tagion_images.outputs.scenario_matrix}} 
        
  #     - name: Pull docker img
  #       run: docker pull tagion/qa-toolkit:$GITHUB_SHA

  #     - name: Prepare directory
  #       run: |
  #         set +e
  #         ulimit -c unlimited
  #         sudo sysctl -w kernel.core_pattern=/tgn/results/core.%u.%p.%t
  #         mkdir -p /tmp/scenario-result/${{ steps.commit.outputs.short }}
  #         sudo chmod -R 777 /tmp/scenario-result/${{ steps.commit.outputs.short }}
            
  # run_scenario:
  #   runs-on: self-hosted
  #   needs: [before_run, create_tagion_images]
  #   strategy:
  #     matrix:
  #       scenario: ${{ fromJson(needs.create_tagion_images.outputs.scenario_matrix) }}
  #   steps:
  #     - id: commit
  #       uses: pr-mpt/actions-commit-hash@v2
  #     - name: Run docker
  #       continue-on-error: true
  #       run: |
  #           SCENARIO=${{ matrix.scenario }}
  #           echo "RUN SCENARIO: $SCENARIO"
  #           mkdir -p /tmp/scenario-result/${{ steps.commit.outputs.short }}/$SCENARIO
  #           sudo chmod -R 777 /tmp/scenario-result/${{ steps.commit.outputs.short }}/$SCENARIO
  #           docker run -d --rm --name ${{ steps.commit.outputs.short }}_$SCENARIO -v /tmp/scenario-result/${{ steps.commit.outputs.short }}/$SCENARIO:/tgn/results/ tagion/qa-toolkit:$GITHUB_SHA timeout --preserve-status 5m run-qa.sh $SCENARIO 0
  #           echo "$SCENARIO executed"
  #     - name: Wait untill docker finished
  #       timeout-minutes: 5
  #       continue-on-error: true
  #       run: |
  #         SCENARIO=${{ matrix.scenario }}
  #         set +e
  #         DELAY=5
  #         while true
  #         do
  #           sleep $DELAY
  #           docker container list
  #           echo ${{ steps.commit.outputs.short }}_$SCENARIO
  #           result=$( docker inspect -f '{{.State.Running}}' ${{ steps.commit.outputs.short }}_$SCENARIO 2>/dev/null )    
  #           echo "Check result: $result"
  #           if [ "$result" = true ]; then
  #               echo 'Container $SCENARIO  exists'
  #               continue
  #           fi
  #           break
  #         done
  #         echo "Container finished scenario"
  #     - name: Clean docker container
  #       if: always()
  #       run: |
  #         SCENARIO=${{ matrix.scenario }}
  #         app="${{ steps.commit.outputs.short }}_$SCENARIO"
  #         if docker ps | awk -v app="$app" 'NR > 1 && $NF == app{ret=1; exit} END{exit !ret}'; then
  #           docker stop "$app" && docker rm -f "$app"
  #         fi
  # after_run:
  #   runs-on: self-hosted
  #   needs: run_scenario
  #   continue-on-error: true
  #   steps:
  #     - id: commit
  #       uses: pr-mpt/actions-commit-hash@v2
  #     - name: log status
  #       run: |
  #           set +e
  #           PATH_TO_LOGS="/tmp/scenario-result/${{ steps.commit.outputs.short }}/**/*.result.json"
  #           REPORT="|Scenario|Test case|Passed|Message|Error|\n|-|-|-|-|-|\n"
  #           failed_scenarios=false
  #             for logfile in $PATH_TO_LOGS
  #             do
  #               echo $logfile
  #               scenario_name=$( cat $logfile | jq '.scenario')
  #               result=$( cat $logfile | jq '.payload[]|(.name,.passed,.message?,.error?)')
  #               echo $scenario_name
  #               echo $result
  #               i=0
  #               while read line; do
  #                   echo "processning $line"
  #                   let "i+=1"
  #                   let "linenum=i%4"
  #                   echo "linenum=$linenum i=$i"
  #                   if [ "$linenum" -eq "1" ]; then
  #                       REPORT+="|$scenario_name|"
  #                   fi
  #                   if [ "$linenum" -eq "2" ]; then
  #                       if [ $line == "true" ]; then
  #                           REPORT+=":heavy_check_mark:|"
  #                       else
  #                           failed_scenarios=true
  #                           REPORT+=":heavy_exclamation_mark:|"
  #                       fi
  #                       continue;
  #                   fi
  #                   if [ "$linenum" -eq "0" ]; then
  #                       REPORT+="$line|\n"
  #                   else
  #                       REPORT+="$line|"
  #                   fi
  #               echo $line; 
  #               done <<<"$result"
  #           done
  #           REPORT=$( echo "${REPORT//null/}" )
  #           REPORT=$( echo "${REPORT//\"/}" )
  #           echo -e "$REPORT"  >> $GITHUB_STEP_SUMMARY
  #           sudo chmod -R 777 /tmp/scenario-result/${{ steps.commit.outputs.short }}
  #           if $failed_scenarios 
  #           then
  #               echo "Scenarious failed"
  #           fi
  #     - name: Set folder permision
  #       if: always()
  #       run: sudo chmod -R 777 /tmp/scenario-result/${{ steps.commit.outputs.short }}
  #     - name: upload artifacts
  #       if: always()
  #       uses: actions/upload-artifact@v2.2.0
  #       with:
  #         name: core-scenarious-results
  #         path: /tmp/scenario-result/${{ steps.commit.outputs.short }}/
  #         if-no-files-found: error
  #         retention-days: 5
  #     ##- name: Clean logs
  #     ##  if: always()
  #     ##  run: sudo rm -rf /tmp/scenario-result/${{ steps.commit.outputs.short }}
