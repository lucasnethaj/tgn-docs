name: Once a day test 
on:
  workflow_dispatch:
  schedule:
    - cron: '0 21 * * *'
env:
  ## Sets environment variable
  TARGET_BUILD: x86_64-linux
  PARALEL: 1
  RETENTION_DAYS_BINS: 7
  TAGION_CACHE_DIR: ~/tagion_cache 
  RUN_SCENARIOUS_PARALEL: true
  ## TODO: add ldc2/dmd switch & version
jobs:
  build_and_unittest:
    runs-on: self-hosted
    steps:
      - name: Cleanup
        run: |
          sudo rm -rf *
          sudo rm -rf .git
          sudo rm -rf .github
          sudo rm -rf .vscode
      - name: Checkout
        uses: actions/checkout@v3
        with:
          ref: refs/tags/passed

      - name: Use cache of libs
        run: |
          if [ -d ${{ env.TAGION_CACHE_DIR }}/${{ env.TARGET_BUILD }} ]; then
            echo "Copying cache"
            mkdir -p ./build/${{ env.TARGET_BUILD }}
            ls ${{ env.TAGION_CACHE_DIR }}/${{ env.TARGET_BUILD}}/
            cp -fr ${{ env.TAGION_CACHE_DIR }}/${{ env.TARGET_BUILD}}/* ./build/${{ env.TARGET_BUILD }}/
            ls ./build/${{ env.TARGET_BUILD }}/
          else 
            echo "Cache not found"
          fi
          
      - name: Run Bdd tests
        run: |
          source ~/.bashrc
          make bddtest TEST_STAGE=acceptance | tail -n 3 | sed 's/\x1B\[[0-9;]*[a-zA-Z]//g' > bddconsole.log
     
      - name: Upload Bdd result
        uses: actions/upload-artifact@v3
        with:
          name: core-bdd-logs
          path: logs/${{ env.TARGET_BUILD }}/bdd/
      - name: Report Bdd result
        run: |
          cat ./bddconsole.log | tail -n 3 >> $GITHUB_STEP_SUMMARY

      # - name: Check bdd result
      #  run: cat ./bddconsole.log | tail -n 1 | grep -E "Test result success!"

     
      - name: Build
        run: |
          source ~/.bashrc
          make tagion -j ${{ env.PARALEL }}
          
      - name: Upload bins
        uses: actions/upload-artifact@v3
        with:
          name: core-bins
          path: build/${{ env.TARGET_BUILD }}/bin/tagion
          retention-days: ${{ env.RETENTION_DAYS_BINS }}
      - name: Set current date as env variable
        run: echo "NOW=$(date +%s)" >> $GITHUB_ENV
      - id: commit
        uses: pr-mpt/actions-commit-hash@v2
      - run: |
          tar -czvf ${{ env.NOW }}_tagion_${{ steps.commit.outputs.short }}.tar.gz ./build/${{ env.TARGET_BUILD }}/bin/tagion
          export AWS_ACCESS_KEY_ID=${{ secrets.AWS_KEY_ID }}
          export AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY}}
          aws s3 cp ${{ env.NOW }}_tagion_${{ steps.commit.outputs.short }}.tar.gz s3://core-tagion
          aws s3 ls core-tagion
      
  create_tagion_images:
    runs-on: self-hosted
    needs: build_and_unittest
    outputs:
      scenario_list: ${{ steps.scenario_list.outputs.scenarious }}
      scenario_matrix: ${{ steps.scenario_list.outputs.scenariousmatrix }}
    steps:
      - name: Cleanup
        run: rm -rf * ; ls; pwd;

      - name: Download Docker context
        uses: actions/checkout@v3
        with:
          repository: tagion/tagion-docker
          token: ${{ secrets.GH_PAT }} # `GH_PAT` is a secret that contains your PAT

      - name: Download bins
        uses: actions/download-artifact@v3
        with:
          name: core-bins
          path: bins
 
      - name: Download QA tools
        uses: actions/checkout@v3
        with:
          repository: tagion/qa-framework
          token: ${{ secrets.GH_PAT }} # `GH_PAT` is a secret that contains your PAT
          path: qa-tools

      - name: Debug info
        run: ls; echo ===========; ls bins; echo ===========; ls qa-tools; pwd;

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      
      - name: Build tagion img
        run: docker build -t tagion/toolkit:$GITHUB_SHA . --target tagion
      - name: Build tagion-qa img
        run: docker build -t tagion/qa-toolkit:$GITHUB_SHA . --target tagion-qa

      - name: Push tagion img
        run: docker image push tagion/toolkit:$GITHUB_SHA
      - name: Push tagion-qa img
        run: docker image push tagion/qa-toolkit:$GITHUB_SHA

      - name: List scenarious
        id: scenario_list
        run: |
          SCENARIOUS=""
          while read f; do
              SCENARIOUS+="${f} "
          done < "./qa-tools/scenarios.txt"
          echo $SCENARIOUS
          echo "scenarious=$SCENARIOUS" >> $GITHUB_OUTPUT
          SCENARIOUS_MATRIX=$(echo $(cat ./qa-tools/scenarios.txt | jq -R -s -c 'split("\n")[:-1]') | sed 's/ //g')
          echo $SCENARIOUS_MATRIX
          echo "scenariousmatrix=$SCENARIOUS_MATRIX" >> $GITHUB_OUTPUT
      - name: Report created docker
        if: success()
        run: |
          echo -e "### :heavy_check_mark: Docker created \n [tagion/toolkit:$GITHUB_SHA](https://hub.docker.com/repository/docker/tagion/toolkit) \n [tagion/qa-toolkit:$GITHUB_SHA](https://hub.docker.com/repository/docker/tagion/qa-toolkit)" >> $GITHUB_STEP_SUMMARY
    
      
  before_run:
    runs-on: self-hosted
    needs: create_tagion_images
    steps: 
    
      - id: commit
        uses: pr-mpt/actions-commit-hash@v2
      - name: Cleanup
        run: rm -rf * ; ls; pwd;

      - name: Debug info - input
        run: echo ${{needs.create_tagion_images.outputs.scenario_list}} 
        
      - name: Debug info - input matrix
        run: echo ${{needs.create_tagion_images.outputs.scenario_matrix}} 
        
      - name: Pull docker img
        run: docker pull tagion/qa-toolkit:$GITHUB_SHA

      - name: Prepare directory
        run: |
          set +e
          ulimit -c unlimited
          sudo sysctl -w kernel.core_pattern=/tgn/results/core.%u.%p.%t
          mkdir -p /tmp/scenario-result/${{ steps.commit.outputs.short }}
          sudo chmod -R 777 /tmp/scenario-result/${{ steps.commit.outputs.short }}
            
  run_scenario:
    runs-on: self-hosted
    needs: [before_run, create_tagion_images]
    strategy:
      matrix:
        scenario: ${{ fromJson(needs.create_tagion_images.outputs.scenario_matrix) }}
    steps:
      - id: commit
        uses: pr-mpt/actions-commit-hash@v2
      - name: Run docker
        continue-on-error: true
        run: |
            SCENARIO=${{ matrix.scenario }}
            echo "RUN SCENARIO: $SCENARIO"
            mkdir -p /tmp/scenario-result/${{ steps.commit.outputs.short }}/$SCENARIO
            docker run -d --rm --name ${{ steps.commit.outputs.short }}_$SCENARIO -v /tmp/scenario-result/${{ steps.commit.outputs.short }}/$SCENARIO:/tgn/results/ tagion/qa-toolkit:$GITHUB_SHA timeout --preserve-status 5m run-qa.sh $SCENARIO $MODE
            echo "$SCENARIO executed"
      - name: Wait untill docker finished
        timeout-minutes: 5
        continue-on-error: true
        run: |
          SCENARIO=${{ matrix.scenario }}
          
          DELAY=5
          while true
          do
            sleep $DELAY
            result=$( docker inspect -f '{{.State.Running}}' ${{ steps.commit.outputs.short }}_$SCENARIO 2>/dev/null )    
            echo "Check result: $result"
            if [ "$result" = true ]; then
                echo 'Container $SCENARIO  exists'
                continue
            fi
            break
          done
          echo "Container finished scenario"
      - name: Clean docker container
        if: always()
        run: |
          SCENARIO=${{ matrix.scenario }}
          app="${{ steps.commit.outputs.short }}_$SCENARIO"
          if docker ps | awk -v app="$app" 'NR > 1 && $NF == app{ret=1; exit} END{exit !ret}'; then
            docker stop "$app" && docker rm -f "$app"
          fi
  after_run:
    runs-on: self-hosted
    needs: run_scenario
    continue-on-error: true
    steps:
      - id: commit
        uses: pr-mpt/actions-commit-hash@v2
      - name: log status
        run: |
            set +e
            PATH_TO_LOGS="/tmp/scenario-result/${{ steps.commit.outputs.short }}/**/*.result.json"
            REPORT="|Scenario|Test case|Passed|Message|Error|\n|-|-|-|-|-|\n"
            failed_scenarios=false
              for logfile in $PATH_TO_LOGS
              do
                echo $logfile
                scenario_name=$( cat $logfile | jq '.scenario')
                result=$( cat $logfile | jq '.payload[]|(.name,.passed,.message?,.error?)')
                echo $scenario_name
                echo $result
                i=0
                while read line; do
                    echo "processning $line"
                    let "i+=1"
                    let "linenum=i%4"
                    echo "linenum=$linenum i=$i"
                    if [ "$linenum" -eq "1" ]; then
                        REPORT+="|$scenario_name|"
                    fi
                    if [ "$linenum" -eq "2" ]; then
                        if [ $line == "true" ]; then
                            REPORT+=":heavy_check_mark:|"
                        else
                            failed_scenarios=true
                            REPORT+=":heavy_exclamation_mark:|"
                        fi
                        continue;
                    fi
                    if [ "$linenum" -eq "0" ]; then
                        REPORT+="$line|\n"
                    else
                        REPORT+="$line|"
                    fi
                echo $line; 
                done <<<"$result"
            done
            REPORT=$( echo "${REPORT//null/}" )
            REPORT=$( echo "${REPORT//\"/}" )
            echo -e "$REPORT"  >> $GITHUB_STEP_SUMMARY
            sudo chmod -R 777 /tmp/scenario-result/${{ steps.commit.outputs.short }}
            if $failed_scenarios 
            then
                echo "Scenarious failed"
            fi
      - name: Set folder permision
        if: always()
        run: sudo chmod -R 777 /tmp/scenario-result/${{ steps.commit.outputs.short }}
      - name: upload artifacts
        if: always()
        uses: actions/upload-artifact@v2.2.0
        with:
          name: core-scenarious-results
          path: /tmp/scenario-result/${{ steps.commit.outputs.short }}/
          if-no-files-found: error
          retention-days: 5
      ##- name: Clean logs
      ##  if: always()
      ##  run: sudo rm -rf /tmp/scenario-result/${{ github.head_ref }}
